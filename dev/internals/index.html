<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Stheno.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Stheno.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Internals</a><ul class="internal"><li><a class="toctext" href="#AbstractGP-1">AbstractGP</a></li><li><a class="toctext" href="#GP-1">GP</a></li><li><a class="toctext" href="#CompositeGP-1">CompositeGP</a></li><li><a class="toctext" href="#GPC-1">GPC</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Internals</a></li></ul><a class="edit-page" href="https://github.com/willtebbutt/Stheno.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Interfaces-1" href="#Interfaces-1">Interfaces</a></h1><p>The primary objects in Stheno are <code>AbstractGP</code>s, which represent Gaussian processes. There are two primary concrete subtypes of <code>AbstractGP</code>:</p><ul><li><code>GP</code>: an atomic Gaussian process, whose <code>MeanFunction</code> and <code>Kernel</code> are specified directly.</li><li><code>CompositeGP</code>: a Gaussian process composed of other <code>AbstractGP</code>s, whose properties are determined recursively from the <code>AbstractGP</code>s of which it is composed.</li></ul><p>This documentation provides the information necessary to understand the internals of Stheno, and to extend it with your own custom functionality.</p><h2><a class="nav-anchor" id="AbstractGP-1" href="#AbstractGP-1">AbstractGP</a></h2><p>The <code>AbstractGP</code> interface enables one to compute quantities required when working with Gaussian processes in practice, namely to compute their <code>logpdf</code> and sample from them at particular locations in their domain.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>mean_vector(f, x)</code></td><td style="text-align: left">The mean vector of <code>f</code> at inputs <code>x</code></td></tr><tr><td style="text-align: left"><code>cov(f, x)</code></td><td style="text-align: left">covariance matrix of <code>f</code> at inputs <code>x</code></td></tr><tr><td style="text-align: left"><code>cov(f, x, x′)</code></td><td style="text-align: left">covariance matrix between <code>f</code> at <code>x</code> and <code>x′</code></td></tr><tr><td style="text-align: left"><code>cov(f, f′, x, x′)</code></td><td style="text-align: left">cross-covariance matrix between <code>f</code> at <code>x</code> and <code>f′</code> at <code>x′</code></td></tr></table><p>It should always hold that <code>cov(f, x) ≈ cov(f, f, x, x)</code>, but in some important cases <code>cov(f, x)</code> will be significantly faster.</p><p><code>GP</code> and <code>CompositeGP</code> are concrete subtypes of <code>AbstractGP</code>, and can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/gp.jl">here</a> and <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/composite/composite_gp.jl">here</a> respectively.</p><h3><a class="nav-anchor" id="diag-methods-1" href="#diag-methods-1">diag methods</a></h3><p>It is crucial for pseudo-point methods, and for the computation of marginal statistics at a reasonable scale, to be able to compute the diagonal of a given covariance matrix in linear time in the size of its inputs. This in turn necessitates that the diagonal of a given cross-covariance matrix can also be computed efficiently as the evaluation of covariance matrices often rely on the evaluation of cross-covariance matrices. As such, we have the following functions:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>cov_diag(f, x)</code></td><td style="text-align: left"><code>diag(cov(f, x))</code></td></tr><tr><td style="text-align: left"><code>cov_diag(f, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, x, x′))</code></td></tr><tr><td style="text-align: left"><code>cov_diag(f, f′, x, x′)</code></td><td style="text-align: left"><code>diag(cov(f, f′, x, x′))</code></td></tr></table><p>The second and third rows of the table only make sense when <code>length(x) == length(x′)</code> of course.</p><h2><a class="nav-anchor" id="GP-1" href="#GP-1">GP</a></h2><p>A <code>GP</code> is constructed in the following manner:</p><pre><code class="language-julia">GP(m, k, gpc)</code></pre><p>where <code>m</code> is its <code>MeanFunction</code>, <code>k</code> its <code>Kernel</code>. <code>gpc</code> is a <code>GPC</code> object that handles some book-keeping, and will be discussed in more depth later (don&#39;t worry it&#39;s very straightforward, and only mildly annoying).</p><p>The <code>AbstractGP</code> interface is implemented for <code>GP</code>s via operations on their <code>MeanFunction</code> and <code>Kernel</code>. It is therefore straightforward to extend the range of functionality offered by <code>Stheno.jl</code> by simply implementing a new <code>MeanFunction</code> or <code>Kernel</code> which satisfies their interface, which we detail below.</p><h3><a class="nav-anchor" id="MeanFunctions-1" href="#MeanFunctions-1">MeanFunctions</a></h3><p><code>MeanFunction</code>s are unary functions with <code>Real</code>-valued outputs with a single-method interface. They must implement <code>elementwise</code> (aliased to <code>ew</code> for brevity) with the signature</p><pre><code class="language-julia">ew(m::MyMeanFunction, x::AbstractVector)</code></pre><p>This applies the <code>MeanFunction</code> to each element of <code>x</code>, and should return an <code>AbstractVector{&lt;:Real}</code> of the same length as <code>x</code>. Some example implementations can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/mean.jl">here</a>.</p><p>Note that while <code>MeanFunction</code>s are in principle functions, their interface does not require that we can evaluate <code>m(x[p])</code>, only that the &quot;vectorised&quot; <code>elementwise</code> function be implemented. This is due to the fact that, in practice, we only ever need the result of <code>elementwise</code>.</p><p>There are a couple of methods of <code>GP</code> which are specialised to particular <code>MeanFunction</code>s:</p><pre><code class="language-julia">GP(k::Kernel, gpc::GPC) == GP(ZeroMean(), k, gpc)
GP(c::Real, k::Kernel, gpc::GPC) == GP(ConstMean(c), k, gpc)</code></pre><h3><a class="nav-anchor" id="Kernels-1" href="#Kernels-1">Kernels</a></h3><p>A <code>Kernel</code> is a binary function, returning a <code>Real</code>-valued result. <code>Kernel</code>s are only slightly more complicated than <code>MeanFunction</code>s, having a four-method interface:</p><pre><code class="language-julia"># Binary methods
ew(k::MyKernel, x::AbstractVector, x′::AbstractVector) # &quot;Binary elementwise&quot;
pw(k::MyKernel, x::AbstractVector, x′::AbstractVector) # &quot;Binary pairwise&quot;

# Unary methods
ew(k::MyKernel, x::AbstractVector) # &quot;Unary elementwise&quot;
pw(k::MyKernel, x::AbstractVector) # &quot;Unary pairwise&quot;</code></pre><p>Again, <code>ew === elementwise</code> and <code>pw === pairwise</code>.</p><p>Note that, as with <code>MeanFunction</code>s, the <code>Kernel</code> interface does not require that one can actually evaluate <code>k(x[p], x′[q])</code>, as in practice this functionality is never <em>really</em> required and would otherwise be extra code to maintain.</p><p>We consider each method in turn.</p><ul><li>Binary elementwise: compute <code>k(x[p], x′[p])</code> for <code>p in eachindex(x)</code>. <code>x</code> and <code>x′</code> are assumed to be of the same length. Returns a subtype of <code>AbstractVector{&lt;:Real}</code>, of the same length as <code>x</code> and <code>x′</code>.</li><li>Binary pairwise: compute <code>k(x[p], x′[q])</code> for <code>p in eachindex(x)</code> and <code>q in eachindex(x′)</code>. <code>x</code> and <code>x′</code> need not be of the same length. Returns a subtype of <code>AbstractMatrix{&lt;:Real}</code> whose size is <code>(length(x), length(x′))</code>.</li><li>Unary elementwise: compute <code>k(x[p], x[p])</code> for <code>p in eachindex(x)</code>. Returns a subtype of <code>AbstractVector{&lt;:Real}</code> of the same length as <code>x</code>.</li><li>Unary pairwise: compute <code>k(x[p], x[q])</code> for <code>p in eachindex(x)</code> and <code>q in eachindex(x)</code>. Returns a subtype of <code>AbstractMatrix{&lt;:Real}</code> whose size is <code>(length(x), length(x))</code>. Crucially, output must be positive definite and (approximately) symmetric.</li></ul><p>Example implementations can be found <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/mean_and_kernel/kernel.jl">here</a>. Often you&#39;ll find that multiple versions of each method are implemented, specialised to different input types. For example the <code>EQ</code> kernel has (at the time of writing) two implementations of each method, one for inputs <code>AbstractVector{&lt;:Real}</code>, and one for <code>ColsAreObs &lt;: AbstractVector</code> inputs. These specialisations are for performance purposes.</p><h3><a class="nav-anchor" id="AbstractGP-Interface-Implementation-1" href="#AbstractGP-Interface-Implementation-1">AbstractGP Interface Implementation</a></h3><p>Given the above, the <code>AbstractGP</code> interface is straightforward to implement for <code>GPs</code>, as each method of <code>mean_vector</code> and <code>cov</code> can be implemented in terms of <code>ew</code> and <code>pw</code>. See <a href="https://github.com/willtebbutt/Stheno.jl/blob/master/src/gp/gp.jl">here</a> for the implementation.</p><p>If you are interested just in working with a single <code>GP</code> object, with a known <code>MeanFunction</code> and <code>Kernel</code>, this is probably as far as you need to go. Simply implement you own fancy <code>Mean</code> and <code>Kernel</code> objects, or approximations to them, and have some fun / do some research.</p><h2><a class="nav-anchor" id="CompositeGP-1" href="#CompositeGP-1">CompositeGP</a></h2><p><code>CompositeGP</code>s are constructed as affine transformations of <code>CompositeGP</code>s and <code>GP</code>s. We describe implemented transformations below.</p><h3><a class="nav-anchor" id="addition-1" href="#addition-1">addition</a></h3><p>Given <code>AbstractGP</code>s <code>f</code> and <code>g</code>, we define</p><pre><code class="language-julia">h = f + g</code></pre><p>to be the <code>CompositeGP</code> sastisfying <code>h(x) = f(x) + g(x)</code> for all <code>x</code>. </p><h3><a class="nav-anchor" id="multiplication-1" href="#multiplication-1">multiplication</a></h3><p>Multiplication of <code>AbstractGP</code>s is undefined since the product of two Gaussian random variables is not itself Gaussian. However, we can scale an <code>AbstractGP</code> by either a constant or (deterministic) function.</p><pre><code class="language-julia">h = c * f
h = sin * f</code></pre><p>will both work, and produce the result that <code>h(x) = c * f(x)</code> or <code>h(x) = sin(x) * f(x)</code>.    </p><h3><a class="nav-anchor" id="composition-1" href="#composition-1">composition</a></h3><pre><code class="language-julia">h = f ∘ g</code></pre><p>for some deterministic function <code>g</code> is the composition of <code>f</code> with <code>g</code>. i.e. <code>h(x) = f(g(x))</code>.</p><h3><a class="nav-anchor" id="conditioning-1" href="#conditioning-1">conditioning</a></h3><pre><code class="language-julia">h = g | (f(x) ← y)</code></pre><p>should be read as <code>h</code> is the posterior process produced by conditioning the process <code>g</code> on having observed <code>f</code> at inputs <code>x</code> to take values <code>y</code>.</p><h3><a class="nav-anchor" id="approximate-conditioning-1" href="#approximate-conditioning-1">approximate conditioning</a></h3><p>TODO (implemented, not documented)</p><h3><a class="nav-anchor" id="cross-1" href="#cross-1">cross</a></h3><p>TODO (implemented, not documented)</p><h2><a class="nav-anchor" id="GPC-1" href="#GPC-1">GPC</a></h2><p>This book-keeping object doesn&#39;t matter from a user&#39;s perspective but, unfortunately, we currently expose it to users. Fortunately, it&#39;s very simple to work with. Say you wish to construct a collection of processes:</p><pre><code class="language-julia"># THIS WON&#39;T WORK
f = GP(mf, kf)
g = GP(mg, kg)
h = f + g
# THIS WON&#39;T WORK</code></pre><p>You should actually write</p><pre><code class="language-julia"># THIS IS GOOD. PLEASE DO THIS
gpc = GPC()
f = GP(mf, kf, gpc)
g = GP(mg, kg, gpc)
h = f + g
# THIS IS GOOD. PLEASE DO THIS</code></pre><p>The rule is simple: when constructing <code>GP</code> objects that you plan to make interact later in your programme, construct them using the same <code>gpc</code> object. For example, DON&#39;T do the following:</p><pre><code class="language-julia"># THIS IS BAD. PLEASE DON&#39;T DO THIS
f = GP(mf, kf, GPC())
g = GP(mg, kg, GPC())
h = f + g
# THIS IS BAD. PLEASE DON&#39;T DO THIS</code></pre><p>The mistake here is to construct a separate <code>GPC</code> object for each <code>GP</code>. This will hopefully error, but might yield incorrect results.</p><p>Alternatively, if you&#39;re willing to place your model in a function you can write something like:</p><pre><code class="language-julia">@model function foo(some arguments)
    f1 = GP(mean, kernel)
    f2 = GP(some other mean, some other kernel)
    return f1, f2
end</code></pre><p>The <code>@model</code> macro just places a <code>GPC</code> on the first line of the function and provides it as an argument to each <code>GP</code> constructed. Suggestions for ways to improve / extend this interface are greatly appreciated.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
